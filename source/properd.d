// Copyright Â© 2013, Peter Wood.

module properd;

import std.conv, std.file, std.string;
import std.stdio : File;
import std.algorithm : map;
import std.array;

/**
 * An exception class for the errors generated by the proper-d code.
 */
class PropertyException : Exception {
   this(string message, Throwable thrown=null) {
      super(message, thrown);
   }
}

/**
 * This function reads in the contents of a file before passing it to the
 * parseProperties() function for processing.
 *
 * Returns:  The associative array returned by parseProperties().
 *
 * Params:
 *    path =  A string containing the path and name of the file to be read.
 */
string[string] readProperties(string path) {
   if(!exists(path)) {
      throw(new PropertyException(text("The '", path, "' file does not exist.")));
   }
   return(parseProperties(readText(path)));
}

/**
 * This function reads in the contents of a file before passing it to the
 * parseProperties() function for processing.
 *
 * Returns:  The associative array returned by parseProperties().
 *
 * Params:
 *    path =  A string containing the path and name of the file to be read.
 */
string[string] readProperties(File* file) {
   return(readProperties(file.name));
}

/**
 * This function takes a string of text and attempts to interpret it using the
 * following set of rules...
 *
 *   1. Blank lines are ignored.
 *   2. Lines that start (after the removal of leading whitespace) with a '#'
 *      are ignored.
 *   3. All other lines will first be stripped of leading and trailing
 *      whitespace then searched for a '=' and, if that is not found, a ':'.
 *      If neither of these is found an exception is thrown. If one of them is
 *      found then the line is split around the first occurrence with the part
 *      of the left hand side becoming a key and the part on the right hand
 *      side become a value in the associative array generated.
 *
 * Returns:  An associative array of strings indexed by strings.
 *
 * Params:
 *    input =  The string containing the text to be parsed.
 */
string[string] parseProperties(string input) {
   string[string] output;

   if(input.length > 0) {
      uint  count;

      foreach(line; input.splitLines()) {
         line = line.strip();
         count++;
         if(line.length > 0) {
            if(line[0..1] != "#") {
               auto index = line.indexOf("=");

               if(index == -1) {
                  index = line.indexOf(":");
               }

               if(index == -1) {
                  throw(new PropertyException(text("Syntax error on line ", count, " of property data.")));
               }

               output[line[0..index].strip()] = line[(index + 1)..$].strip();
            }
         }
      }
   }

   return(output);
}

/**
 * Convenience function that attempts to extract a property value from a
 * property list (an associative array of strings indexed by strings) and
 * convert it to a specified type.
 *
 * Params:
 *    properties =   The associative array to locate the property in.
 *    name =         The name the value is currently keyed under.
 *    alternative =  The value to return in the case that the properties list
 *                   doesn't contain the named property. Defaults to whatever
 *                   the default initialization value for the desired type
 *                   is.
 */
T as(T)(string[string] properties, string name, T alternative=T.init) {
   T result = alternative;
   string value  = (name in properties ? properties[name] : null);

   if(value !is null) {
      try {
         result = to!(T)(value);
      } catch(Exception exception) {
         throw(new PropertyException(text("Cannot convert the value of the '", name, "' property ('", value, "') to a ", typeid(value), ".")));
      }
   }

   return(result);
}

/**
 * Template specialization of the as() function for generating boolean values.
 * This function will recognise "true", "1", "yes" and "on" as values that
 * convert to a boolean true, with everything else converting to false.
 */
bool as(T : bool)(string[string] properties, string name, T alternative=T.init) {
   bool   result = alternative;
   string value  = (name in properties ? properties[name] : null);

   if(value !is null) {
      value  = value.toLower();
      result = (value == "true" || value == "1" || value == "yes" || value == "on");
   }

   return(result);
}

/**
 * Convenience function that attempts to extract a property value from a
 * property list (an associative array of strings indexed by strings),
 * split the value with separater, convert each value to a specified type
 * and return as an array.
 *
 * Params:
 *    properties =   The associative array to locate the property in.
 *    name =         The name the value is currently keyed under.
 *    sep =          value separater
 */
T[] asArray(T)(string[string] properties, string name, string sep = ",") {
   T[] result;
   string value  = (name in properties ? properties[name] : null);

   if(value !is null) {
      try {
         result = value.split(sep).map!strip.map!(to!(T)).array;
      } catch(Exception exception) {
         throw(new PropertyException(text("Cannot convert the value of the '", name, "' property ('", value, "') to a ", typeid(value), ".")));
      }
   }

   return(result);
}

